쿠버네티스의 핵심 6가지
1. 대규모의 유저 요청을 받아들이는 서비스의 백엔드에 적합한 플랫폼으로, 지속적통합(CI)과 지속적배포(CD)에 적합한 구조를 가진다.
2. 퍼블릭 클라우드와 온프레미스에서 동일한 방식으로 사용 가능하다.
3. 컨테이너 기술을 통해 애플리케이션과 서버 인프라를 분리하여 변화에 대응할 수 있는 유연성과 확정성을 제공한다.
4. CNCF는 많은 기업의 지지를 받으며 빠르게 성장해, 정식 서비스에 운영할 수 있을 정도로 성숙하여 많은 기업들이 활용 하고 있다.
5. EKS, IKS, NKS, GKS, AKS등 클라우드 관리형 쿠버네티스 서비스를 제공하고 있어, 온프레미스에서도 클라우드로 쉽게 마이그레이션이 가능 하다.
6. 쿠버네티스 아키텍쳐는 마스터와 노드로 구성되며, 마스터가 노드를 제어, 노드에서 컨테이너가 기동 된다.


컨테이너(도커) 하용 하는 이유

1. 인프라의 사용률 향상
- 하나의 물리 서버나 가상 서버 위에서 여러 개의 컨테이너를 돌릴 수 있다.
- CPU와 메모리 사용률을 높여 하드웨어를 효율적으로 사용 할 수 있다.

2.빠른 기동 시간
- VM, 물리서버 보다 기동 시간이 빠름
- os, app등의 이미지를 쉽게 얻을 수 있다
- 설치 및 설정 작업이 줄어든다.
- 네트워크. 볼륨(외부 저장)을 소프트웨어 정의 오브젝트로 작성 할 수 있다.

3. 불변 실행 환경
- 앱 실행에 필요한 software 모두 포함하여 컨테이너 작성 가능
- 특정 서버 환경에 대한 종속성을 배재할 수 있다.
- 개발, 운영 환경의 차이를 줄 일 수 있다.



쿠버네티스 도커 연동

- 쿠버네티스틑 도커를 컨테이너 런타임 환경으로 사용

리눅스 커널 기술
1. 네임스페이스
- 리눅스 커널에 사용된 기술로 컨테이너가 하나의 독립된 서버와 같이 동작 할 수 있게 한다. 특정 프로세스를 다른 프로세스로부터 분리시켜 같은 네이스페이스 내에서만 접근하게 제어 할 수 있다.
pid(process id) : 리눅스 커널의 프로세스 ID 분리, Net(networking) : 네트워크 인터페이스 관리 , ipc(inter process Communication) : 프로세스간 통신 접근 관리
mnt(mount) : 파일 시스템의 마운트 관리, uts(unix Timesharing system) : 커널과 버전 식별자 관리

2. 컨트롤 그룹-> docker는 리눅스 커널의 cgroup을 사용. 프로세스별로 cpu  시간, 메모리 사용량과 같은 자원을 감시하고 제한함.
3. 유니온 파일 시스템 -> 다른 파일스템에서 파일이나 디렉토리를 투과적으로 겹처서, 하나의 일관적인 파일 시스템으로 사용 할 수 있게 한다.
4. OCI(open container initiative) 

쿠버네티스 API란?
-> 쿠버네티스에 대한 조작은 모두 API를 통해 이뤄진다. kubectl은 마스터 노드상의 kube-apiserver에게 쿠버네티스 API규약에 맞게 기술된 목표 상태 선언서인 yaml형 식 혹은 json형식으로 전송하여
오브젝트를 만들고, 바꾸고, 제거하는 일을 한다. 

오브젝트란?
K8s 클러스터 내부의 엔티티로서 파드, 컨트롤러, 서비스 등의 인스턴스를 의미한다. 각각의 오브젝트는 API의 리소스 종류에 맞게 설정 되고 생성됨. 오브젝트는 지정된 상태가 유지되도록 쿠버네티스에 의해 제어됨.
각 오브젝트는 메타데이터(yaml or json)에 기술된 이름에 의해 식별, 오브젝트 생성시 반드시 네이밍 해야함. 네임스페이스는 k8s클러스터를 논리적으로 분할하여 사용하기 위해 존재하는 기능.

워크로드란?
오브젝트의 카테고리르 나타내는 용어로 컨테이너, 파드 , 컨트롤러 그룹을 의미함. 컨테이너의 실행을 관리 하기 위해 사용. 

컨테이너
-> 반드시 파드내에서 실행 되어야함. 컨테이너 기동 시 설정할 수 있는 항목은 이미지의 이름, 실행 명령어, 실행 인자, 환경 변수, 불륨, Cpu 사용 시간과 메모리 크기의 요청값 및 상한값 등 있음.

파드
-> 컨테이너를 실행하기 위한 오브젝트,내부의 컨테이너들은 파드의 IP주소와 포트 번호를 공유, 내부 컨테이너들은 Localhost로 서로 통신 할 수 있다, System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여
서로 통신함, 내부 컨테이너들은 파드의 볼륨을 마운트 하여 파일 시스템을 공유 할 수 있다, 다만 해당 기능은 같은 파드에 있는 컨테이너에만 해당 됨.

kubectl delete 실행 할 떄 옵셔 "--grace--period=초" 옵션으로 유예 시간 별도로 지정 가능.


Flannel
-> 간단한 L3 네트워크를 노드 간에 구추한다 각 노드 위에 서브넷을 구성해서 한 노드 위의 파드가 다른 노드위의 파드랑 통신할 수 있도록 한다. Flannel의 파드는 데몬셋 컨트롤러에 의해 배포됨. k8s 클러스터에
새로운 노드 추가되면 자동적으로 파드 네트워크가 확장됨. 그러나 접근 제어 기능을 제공 하지는 않는다. 

Calico
-> 노드 간 파드 통신에 더해 네트워크 접근 제어 기능을 제공. 

서비스의 기본
-> k8s서비스는 클라이언트의 요청을 파드에 전달하는 역활을 담당. 해당 서비스가 필요한 이유는 pod 주소가 기동 할 떄마다 변경 되기 떄문이다. 

파드는 기동 될 때 라벨이나 IP 주소를 포함한 자신의 오브젝트 정보를 마스터 노드의 etcd의 등록 함. 그래서 서비스의 전송처를 결정할 때 실렉터(selector)의 라벨에 일치하는 파드를 etcd에서 조회하여 
전송할 파드의 IP주소를 취득한다. 이처럼 라벨에 의해 대상 오브젝트를 결정하는 것이 k8s의 기본적이 동작이다.

대표IP주소
-> 서비스는 파드의 그룹을 대표하여 클라이언트의 요청을 받기 위해 대표 IP주소를 가진다. 헤드리스로 지정하면 대표 IP주소를 획득 하지 않고, 파드의 IP 주소를 직접 내부 DNS에 설정함.


부하분산
->서비스의 대표 IP주소에 도착한 요청은 실렉터의 라벨과 일치하는 파드에 전송된다. 이를 위한 모듈인 kube-proxy는 초창기에는 커널의 유저 공간에서 동작하는 프록시 서버였지만, 지금은 iptables, ipvs
를 관리하는 프로그램으로 바뀌었다.


이름 해결
-> 서비스는 IP주소와 서비스명을 K8s 클러스터의 내부 DNS에 등록 한다. k8s 클러스터 내의 파드에서는 서비스 이름으로 접근 가능

환경 변수
-> 서비스가 만들어지고 나서 생성되는 파드의 컨테어너에는 환경 변수가 설정 되어 있음. 컨테이너 안의 애플리케이션 코드에서는 환경 변수를 이용해서 서비스의 대표IP주소를 얻을 수 있다

서비스 타입
-> 서비스를 설정할 때는 해당 서비스를 이용하는 클라이언트를 고려하여 서비스 타입을 지정한다. 

어피니티
-> 기본적으로 부하분산에 사용되는 알고리즘은 랜덤이다. 클라이어트에 따라 전송 되는 파드를 고정하고 싶은 경우에는 sessionAffinity 항목에 ClientIP를 설정. 그리고 HTTP 헤드 안의 쿠키 값에 따라
전송되는 파드를 고정하고 싶은경우에는 뒤에서 설명할 인그레스를 이용해야한다.

docekr images는 운영체제와 소프트웨어를 담고 있는 컨테이너 실행 이전의 상태. 각 이미지의 경우 'repo:tag'로 식별 됨

도커의 리포지터리는 이미지 보관소를 말함. 리포지터리의 이름에 버전 등을 의미하는 태그를 붙여서 각각의 이미지를 구별 하여 보관 가능. 태그 생략하면 최신을 의미하는 lastest가 사용됨.

컨테이너는 3가지의 상태를 가짐. 
